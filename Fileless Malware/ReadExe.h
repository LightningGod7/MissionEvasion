#pragma once

#include <vector>
#include <array>
#include <Windows.h>

#include "PE.h"

NewProcessInfo GetPEInfo(const LPCSTR lpPathToExe)
{
	NewProcessInfo processInfo = { 0 };

	// GET HANDLE TO EXE FILE
	HANDLE hFile = CreateFileA(lpPathToExe, GENERIC_READ, FILE_SHARE_READ,
		nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

	// GET EXE FILE SIZE
	DWORD dwFileSize = GetFileSize(hFile, nullptr);


	//CHECK IF COULD GET FILE SIZE
	if (dwFileSize == -1)
	{
		fprintf(stderr, "Could not get size of file. ERROR: %X\n", GetLastError());
		exit(-1);
	}

	// INITIALIZE CLASS ATTRIBUTES
	processInfo.pFileData = std::unique_ptr<BYTE[]>(new BYTE[dwFileSize]);			//POINTER TO ARRAY CONTAINING FILE DATA
	processInfo.dwFileSize = dwFileSize;

	DWORD dwBytesRead = 0;

	// GET FILE DATA AND STORE IN BUFFER IN MEMORY
	bool bReadFileStatus = BOOLIFY(ReadFile(hFile, processInfo.pFileData.get(), dwFileSize, &dwBytesRead, nullptr));

	//CHECK IF COULD READ FILE
	if (!bReadFileStatus)
	{
		fprintf(stderr, "Could not read file. ERROR: %X\n", GetLastError());
		exit(-1);
	}

	//CHECK IF READ WAS COMPLETE
	if (dwBytesRead != dwFileSize)
	{
		fprintf(stderr, "Could not complete entire read.\n"
			"Bytes read = %ul -- Bytes that should be read = %ul\n",
			dwBytesRead, dwFileSize);
		exit(-1);
	}

	// INITIALIZE DOS & NT HEADERS
	processInfo.pDosHeader = (IMAGE_DOS_HEADER*)&(processInfo.pFileData.get()[0]);
	processInfo.pNtHeaders = (IMAGE_NT_HEADERS*)&(processInfo.pFileData.get()[processInfo.pDosHeader->e_lfanew]);

	CloseHandle(hFile);

	return processInfo;
}

std::vector<std::array<BYTE, READ_WRITE_SIZE>> SplitFile(const char* const pPathToFile)
{
	// INITIALIZE VECTOR CLASS (STORES ARRAYS OF READ_WRITE_SIZE BYTES)
	std::vector<std::array<BYTE, READ_WRITE_SIZE>> splitFile;

	NewProcessInfo newProcessInfo = GetPEInfo(pPathToFile);
	for (DWORD i = 0; i < newProcessInfo.dwFileSize; i += READ_WRITE_SIZE)
	{
		std::array<BYTE, READ_WRITE_SIZE> splitArray = { 0 };
		memcpy(splitArray.data(), &newProcessInfo.pFileData.get()[i], READ_WRITE_SIZE);

		splitFile.push_back(splitArray);
	}

	return splitFile;
}