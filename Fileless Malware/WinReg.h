#pragma once

#include <array>
#include <cstdio>
#include <memory>
#include <string>
#include <vector>
#include <Windows.h>

#include "PE.h"

const HKEY OpenRegKey(HKEY hRegPath, const char* const strKeyName, const bool bKeyCreated = true)
{
    HKEY hKey = nullptr;
    DWORD dwResult;

    // CREATE THE REGISTRY KEY
    LONG lCreateKeyStatus = RegCreateKeyExA(
        hRegPath,
        strKeyName, 0, NULL, 0,
        KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY,
        NULL, &hKey, &dwResult);

    // CHECK IF KEY CREATED SUCCESSFULLY
    if (lCreateKeyStatus != ERROR_SUCCESS)
    {
        fprintf(stderr, "Could not create key, ERROR: %X\n", lCreateKeyStatus);
        exit(-1);
    }

    // IF KEY WAS CREATED
    if (bKeyCreated && dwResult == REG_CREATED_NEW_KEY)
    {
        fprintf(stdout, "Created new registry key.\n");
    }
    // IF KEY ALREADY EXISTS
    else
    {
        fprintf(stdout, "Opened existing registry key.\n");
    }

    return hKey;
}

void WriteToRegKeyValue(const HKEY hKey, const char* const strValueName, const BYTE* pBytesOfFile, const DWORD dwSplitSize)
{
    // B64 ENCODE THE FILE DATA
    std::string strEncodedFileData = base64_encode(pBytesOfFile, dwSplitSize);

    // WRITE ENCODED FILE DATA TO REGISTRY KEY VALUE AS REG_SZ
    LONG lWriteToRegStatus = RegSetValueExA(hKey, strValueName, 0, REG_SZ,
        (const BYTE*)strEncodedFileData.c_str(),
        strEncodedFileData.length());

    //CHECK IF VALUE WAS WRITTEN
    if (lWriteToRegStatus != ERROR_SUCCESS)
    {
        fprintf(stderr, "Could not write registry value. ERROR: %X\n",
            lWriteToRegStatus);
        exit(-1);
    }

}

const std::array<BYTE, READ_WRITE_SIZE> ReadRegKeyValue(const char* const strKeyName,
    const char* const strValueName, bool& bErrorOccured, bool& bReadStatus)
{
    DWORD dwType = 0;

    // ACCOUNT FOR CHANGE IN SIZE
    const DWORD dwMaxReadSize = READ_WRITE_SIZE * 2;
    DWORD dwReadSize = dwMaxReadSize;

    char strEncodedFileData[READ_WRITE_SIZE * 2] = { 0 };

    //GET REGISTRY VALUE STRING
    LONG lGetRegValueStatus = RegGetValueA(HKEY_CURRENT_USER, strKeyName, strValueName,
        RRF_RT_REG_SZ, &dwType, strEncodedFileData, &dwReadSize);


    // CHECK IF COULD GET REGISTRY VALUE
    if (!bReadStatus)
    {
        if (lGetRegValueStatus != ERROR_SUCCESS)
        {
            fprintf(stderr, "Could not read registry value. Error = %X\n",
                lGetRegValueStatus);
            bErrorOccured = true;
        }
        if (dwType != REG_SZ || (dwReadSize == 0 || dwReadSize > dwMaxReadSize))
        {
            fprintf(stderr, "Did not correctly read back a string from the registry.\n");
            bErrorOccured = true;
        }
        else
        {
            bReadStatus = true;
        }

    }

    // CHECK IF REACHED END OF FILE
    else if (lGetRegValueStatus != ERROR_SUCCESS)
    {
        fprintf(stderr, "Successfully read to end of file\n",
            lGetRegValueStatus);
        bErrorOccured = true;
    }

    // INITIALIZE ARRAY TO HOLD DECODED FILE DATA
    std::array<BYTE, READ_WRITE_SIZE> pBytesOfFile = { 0 };

    //B64 DECODE FILE DATA
    std::string strDecoded = base64_decode(std::string(strEncodedFileData));

    //MEMCPY THE DECODED BYTES INTO THE ARRAY
    (void)memcpy(pBytesOfFile.data(), strDecoded.c_str(), strDecoded.size());



    return pBytesOfFile;
}

//NewPEInfo StoreFileBytesInMemory(const char* const strKeyName, std::string strValuePrefix)
//{
//    NewPEInfo NewPEInfo = { 0 };
//    std::vector<std::array<BYTE, READ_WRITE_SIZE>> splitFile;
//
//    // START FROM SUFFIX OF 1
//    size_t ulValueSuffix = 1;
//
//    // REGISTRY VALUE NAME TO BE PREFIX ('PART') + SUFFIX (#)
//    std::string strFullName(strValuePrefix + std::to_string(ulValueSuffix));
//
//    bool bErrorOccured = false;
//    bool bReadStatus = false;
//    auto partFile = ReadRegKeyValue(strKeyName, strFullName.c_str(), bErrorOccured, bReadStatus);
//
//    // ITERATE THROUGH ALL VALUES WITH THE NAME ['Part#'] OF THE REGISTRY KEY
//    while (!bErrorOccured)
//    {
//        // APPEND ARRAY INTO VECTOR
//        splitFile.push_back(partFile);
//
//        ++ulValueSuffix;
//        strFullName = strValuePrefix + std::to_string(ulValueSuffix);
//
//        // STORE VALUE INTO ARRAY
//        partFile = ReadRegKeyValue(strKeyName, strFullName.c_str(), bErrorOccured, bReadStatus);
//    }
//
//    // INITIALIZE UNIQUE POINTER TO START OF EACH ARRAY IN THE VECTOR
//    NewPEInfo.pFileData = std::unique_ptr<BYTE[]>(new BYTE[splitFile.size() * READ_WRITE_SIZE]);
//    memset(NewPEInfo.pFileData.get(), 0, splitFile.size() * READ_WRITE_SIZE);
//
//    size_t ulArrayIndex = 0;
//
//    // ITERATE THROUGH ALL ARRAYS IN THE VECTOR
//    for (auto& split : splitFile)
//    {
//        // MEMCPY ARRAY TO THE SOURCE PROCESS INFO CLASS FILEDATA BUFFER
//        (void)memcpy(&NewPEInfo.pFileData.get()[ulArrayIndex * READ_WRITE_SIZE], splitFile[ulArrayIndex].data(),
//            READ_WRITE_SIZE);
//        ++ulArrayIndex;
//    }
//
//    // INITIALIZE POINTER TO SOURCE PROCESS PE's DOS & NT HEADERS
//    NewPEInfo.pDosHeader = (IMAGE_DOS_HEADER*)&(NewPEInfo.pFileData.get()[0]);
//    NewPEInfo.pNtHeaders = (IMAGE_NT_HEADERS*)&(NewPEInfo.pFileData.get()[NewPEInfo.pDosHeader->e_lfanew]);
//
//    // INITIALIZE POINTER TO SOURCE PROCESS PE'S RELOCATION TABLE
//    NewPEInfo.pRelocationTable = (IMAGE_DATA_DIRECTORY*)&(NewPEInfo.pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);
//    return NewPEInfo;
//}